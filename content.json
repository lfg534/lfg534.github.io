{"meta":{"title":"534's blog","subtitle":"blog","description":"","author":"卢浮宫","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-04-28T08:09:38.000Z","updated":"2022-05-06T03:12:37.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-28T08:05:09.000Z","updated":"2022-05-04T13:34:54.950Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-11T14:48:07.000Z","updated":"2022-05-11T15:26:43.206Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"算法-图论","slug":"算法笔记","date":"2022-05-06T05:46:49.000Z","updated":"2022-05-11T15:26:33.886Z","comments":true,"path":"2022/05/06/算法笔记/","link":"","permalink":"http://example.com/2022/05/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"图论知识存图方式作为一个图，如果要将它储存起来，自然是需要一种存图的方法。这里使用的是链式前向星存图 最短路最短路就是到某个点的最短路径的距离，最常用的有三种方法 bellman-ford 时间复杂度：O(n m) 可解决存在负边的情况 三角不等式：dis[b] &lt;&#x3D; dis[a] + w 123456789101112131415161718192021222324252627282930313233343536373839/* 走k次能从1号点到n号点的最短路 */long long dis[N], last[N];struct E &#123; int u, v, w;&#125;Edge[M];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++ ) cin &gt;&gt; Edge[i].u &gt;&gt; Edge[i].v &gt;&gt; Edge[i].w; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; for (int i = 0; i &lt; k; i++ ) &#123; memcpy(last, dis, sizeof(dis)); for (int j = 0; j &lt; m; j++ ) &#123; auto e = Edge[j]; dis[e.v] = min(dis[e.v], last[e.u] + e.w); &#125; &#125; if (dis[n] &gt; 0x3f3f3f3f / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; Dijkstra 时间复杂度：O(mlogn) 没有负权边的稠密图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 求1到其他点的最短路 dis[i] 为到i点的最短距离 */#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10, M = 2e5 + 10;typedef pair &lt;long long, int&gt; PII;priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq; // 小根堆存放最小值 long long dis[N];bool vis[N];struct E &#123; int to, w, next;&#125;Edge[M];int tot, Head[N];inline void Add_edge(int u, int v, int w)&#123; Edge[tot] = &#123;v, w, Head[u]&#125;; Head[u] = tot ++;&#125;void dijkstra(int s)&#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; // 初始化距离1到它本身距离为0 pq.push(&#123;0, s&#125;); while(!pq.empty()) &#123; int u = pq.top().second; //对u进行操作 pq.pop(); // 操作完后弹出队列 if (vis[u]) continue; vis[u] = true; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (dis[u] + Edge[i].w &lt; dis[v]) // 松弛操作 &#123; dis[v] = dis[u] + Edge[i].w; // 更新最短路 pq.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; Add_edge(u, v, w); &#125; dijkstra(1); for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; dis[i] &lt;&lt; &#x27; &#x27;; return 0;&#125; SPFA 一般情况下时间复杂度为：O(m) 最坏：(nm) 可以判断负环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 1e5 + 10;int dis[N];bool st[N];struct E&#123; int to, next, w;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void addedge(int u, int v, int w)&#123; Edge[tot] = &#123;v, Head[u], w&#125;; Head[u] = tot ++;&#125;void spfa()&#123; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; queue &lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) &#123; int u = q.front(); q.pop(); st[u] = false; for (int i = Head[u]; ~i; i = Edge[i].next ) &#123; int v = Edge[i].to; if (dis[v] &gt; dis[u] + Edge[i].w) &#123; dis[v] = dis[u] + Edge[i].w; if (!st[v]) // 不存在就入队列 &#123; q.push(v); st[v] = true; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); int n, m; cin &gt;&gt; n &gt;&gt; m; while(m --) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; spfa(); if (dis[n] == 0x3f3f3f3f) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; Floyd(求多源汇)多源汇就是任意两个点的最短路 时间复杂度：O(n ^ 3) 基于动态规划 更新：到只经过1到k-1个点跟到k个点的最小 12345678/* 实现后d[i][j] 就是i到j的最短路 */void floyd()&#123; for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; 最近公共祖先（lCA）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 给定一棵 n 个结点树和 m 次询问 (u,v)，请你回答 u,v 两个结点的最近公共祖先是谁 */#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 5e5 + 10;int n, m, s;struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];int dp[20][N], dep[N];inline void add_edge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot++;&#125;void dfs(int u, int f)&#123; dep[u] = dep[f] + 1; dp[0][u] = f; for (int i = 1; (1 &lt;&lt; i) &lt; dep[u]; i++ ) dp[i][u] = dp[i - 1][dp[i - 1][u]]; // 初始化dp数组 for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); &#125;&#125;int lca(int u, int v)&#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] != dep[v]) &#123; u = dp[(int)log2(dep[u] - dep[v])][u]; &#125; for (int i = 19; i &gt;= 0; i --) &#123; if (dp[i][u] != dp[i][v]) &#123; u = dp[i][u]; v = dp[i][v]; &#125; &#125; if (u == v) return u; else return dp[0][u];&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt; n; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; add_edge(u, v); add_edge(v, u); &#125; dfs(s, 0); while (m --) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; endl; &#125; return 0;&#125; 最长不下降子序列(LIS) 3 1 2 2 1 3 的最长不下降子序列为 1 2 2 3 123456for (int i = 1; i &lt;= n; i++ ) &#123; if (a[i] &gt;= d[len]) d[++len] = a[i]; else *upper_bound(d + 1, d + 1 + len, a[i]) = a[i]; &#125; cout &lt;&lt; len &lt;&lt; endl; 最长公共子序列(LCS)标准版 给定两个数列，求他们的最长公共子序列 1234567for (int i = 1; i &lt;= n; i++ ) for (int j = 1; j &lt;= m; j++ ) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; 全排列版 给出 1,2,…,n 的两个排列 P1 和 P2，求它们的最长公共子序列 1234567891011for (int i = 1; i &lt;= n; i++ )1 mp[a[i]] = i;for (int i = 1; i &lt;= n; i++ ) b[i] = mp[b[i]]; //一个映射关系for (int i = 1; i &lt;= n; i++ )&#123; if (b[i] &gt;= d[len]) d[++len] = b[i]; else *upper_bound(d + 1, d + 1 + len, b[i]) = b[i];&#125;cout &lt;&lt; len &lt;&lt; endl; 树的重心 重心的性质： 对于非负权的数，树上所有点到树的重心的距离之和最短 一棵树的重心一定在根节点所在重链上 若向一棵树中插入或者删除一个点，那么树的重心最多移动一个单位 如果树有两个重心，那么这两个重心一定相邻 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 给定一棵树，求任意节点到一个固定节点的最小值 */#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;long long n, rt, siz[N], maxp[N], dep[N];long long ans;struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void add_edge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot ++;&#125;void dfs1(int u, int f)&#123; siz[u] = 1; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); siz[u] += siz[v]; maxp[u] = max(maxp[u], siz[v]); &#125; maxp[u] = max(maxp[u], n - siz[u]); if (maxp[u] &lt; maxp[rt]) rt = u; &#125;void dfs2(int u, int f)&#123; dep[u] = dep[f] + 1; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs1(v, u); &#125;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i ++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; add_edge(u, v); add_edge(v, u); &#125; maxp[rt] = n; dfs1(1, 0); dfs2(rt, 0); for (int i = 1; i &lt;= n; i ++ ) &#123; ans += dep[i] - dep[rt]; // 从重心到其他节点的距离 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 树的直径 树上节点之间最长的一条简单路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int ans, dep[N];struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void addedge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot ++; &#125;void dfs(int u, int f)&#123; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); ans = max(ans, dep[v] + 1 + dep[u]); dep[u] = max(dep[u], dep[v] + 1); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); addedge(v, u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最小生成树Kruskal匈牙利算法（二分图匹配） 给定一个二分图，其左部点的个数为 n，右部点的个数为 m，边数为 e，求其最大匹配的边数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int N = 510;vector &lt;int&gt; G[N];int match[N], vis[N];bool dfs(int u, int tag)&#123; if(vis[u] == tag) return false; vis[u] = tag; for(auto v : G[u]) &#123; if(!match[v] || dfs(match[v], tag)) &#123; match[v] = u; return true; &#125; &#125; return false;&#125;int main()&#123; int n, m, e, ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; e; for (int i = 0; i &lt; e; i++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); &#125; for (int i = 1; i &lt;= n; i++ ) &#123; if (dfs(i, i)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"test","slug":"test","date":"2022-04-27T09:23:25.000Z","updated":"2022-05-06T05:49:43.020Z","comments":true,"path":"2022/04/27/test/","link":"","permalink":"http://example.com/2022/04/27/test/","excerpt":"","text":"labal2023年还没到…. 小心开车 安全至上 这是三片呢？还是四片？ 你电量充足吗 剪刀石头布 前端最讨厌的浏览器 tag-hide哪個英文字母最酷？ 查看答案 C 因為西裝褲(C裝酷) 門裏站着一個人? Click 不 是两个","categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"主题","slug":"主题","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello 534","slug":"hello-world","date":"2022-04-27T08:13:19.313Z","updated":"2022-05-02T08:04:35.428Z","comments":true,"path":"2022/04/27/hello-world/","link":"","permalink":"http://example.com/2022/04/27/hello-world/","excerpt":"","text":"Welcome to my website learn how to use hexo Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server by 534","categories":[],"tags":[]}],"categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"主题","slug":"主题","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}