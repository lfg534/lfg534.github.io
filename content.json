{"meta":{"title":"534's blog","subtitle":"blog","description":"","author":"卢浮宫","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-04-28T08:09:38.000Z","updated":"2022-05-06T03:12:37.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-28T08:05:09.000Z","updated":"2022-05-04T13:34:54.950Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-11T14:48:07.000Z","updated":"2022-05-11T15:35:30.389Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"2023讯飞星火营","slug":"2023讯飞星火营","date":"2024-02-19T09:18:07.000Z","updated":"2024-04-10T02:42:49.369Z","comments":true,"path":"2024/02/19/2023讯飞星火营/","link":"","permalink":"http://example.com/2024/02/19/2023%E8%AE%AF%E9%A3%9E%E6%98%9F%E7%81%AB%E8%90%A5/","excerpt":"","text":"s 23暑假讯飞星火营 初到合肥 其实一开始对讯飞这个公司并没有什么了解，只知道之前是跟语音输入相关的公司。所以实验室老师推荐后就填表参加了（此时并不知道其他高校都是较知名院校），也是因为一位副总裁是吉安人，且星星之火可以燎原，就选择我们学校作为发起地了。 8.15星火大模型2.0发布会 在发布会还是比较震撼的，比较第一次现场参加这种大型的发布会，到现场的有很多讯飞利用星火大模型已经做出的一些学习机、iflycode等产品。体验还是很新奇的。 开营 科大讯飞董事长刘庆峰亲自为我们开营，并且现场答疑，给我们讲了很多精彩的内容。他分享了他的创业经历，从一个大学生到一个科技企业家，从一个语音识别专家到一个通用人工智能领导者，要有梦想，要有勇气，要有创新，要有责任。他希望我们能够在星火营的培训中收获知识、技能、经验和友谊，成为通用人工智能时代的领军人才。 课程 后面几天的培训，我们听了认知智能技术解读、语音技术及应用、多模态技术及应用、NLP原理等多个课程，了解了最前沿的大模型技术逻辑和原理。这些课程和实践让我更了解了讯飞的业务和产品，也为我们后续的课题实践打基础。 分组 进行了导师分组交流活动。这个活动由五位来自不同领域和背景的导师负责，我们在提前一天填了问卷，选择的时候根本没想到会分到司法领域，但是分组出来的时候倒是想看看大模型能在司法领域做点啥，所以就没换分组。 评测 导师发了个任务说是要对模型进行一个评测，然后评测的方面由我们自己定，可以全面也可以聚焦。但是只给了一天？所以那天我们好像搞到了很晚，但是评测的老师也不管多晚也继续评测 这个评测是对比gpt和星火的能力 我们选了几个指标进行评测 然后人工数据标记，并且打分(所以非常慢，我们是倒数第二个汇报的) anyway 最后得到的结果就是中文领域星火领先🤔 项目 好了 终于到了最关键的部分了，剩下五天还是四天，我们最后的任务就是实现我们所选课题的导师的任务，基本要求是能够用大模型去帮助生成一个起诉状，在这之前我们根本不知道起诉状是什么。所以要先了解，这是一个怎么样的文件 有那些必要信息 ok，我们的思路是，前端用框架 后端接星火接口，然后我们在用户和星火之间弄一个类似桥梁的作用，不断提示引导用户按照步骤给出起诉状的必要信息，诉求等。然后再用星火，设计prompt，去提取这里面的关键信息并记录，最终写到docx文件里生成一个docx文件 我们有三个队伍都是这个组的，所以我们三个队伍在一个房间，也算是暗自比较，有一组就比较摆，已经开始游合肥了🤓 另一组就也在弄，但是貌似调的不是很顺利，我们算是这三组里比较拼的了，最后在汇报的时候挺进下一环节，就准备ppt、演示，去迎接第二天路演，又熬一通宵，疯狂的是到四点去k歌到早上回酒店睡几个小时又跑去路演，哈哈以至于最后领导问我在设计prompt的过程中语无伦次🤣 但好在领导觉得我们这是法律领域的具体落地应用，最后效果也是可以成功的生成出起诉状，所以我们拿了第二名的成绩，奖金5w耶！ 也算是功夫不负有心人🙃(●’◡’●)","categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"},{"name":"感悟","slug":"感悟","permalink":"http://example.com/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"python 中的lambda表达式","slug":"lambda","date":"2022-05-19T13:30:12.000Z","updated":"2022-07-18T03:38:09.290Z","comments":true,"path":"2022/05/19/lambda/","link":"","permalink":"http://example.com/2022/05/19/lambda/","excerpt":"","text":"lambda 的使用可以使代码更简洁 lambda 函数是一种小的匿名函数。 函数可接受任意数量的参数，但只能有一个表达式。 lambda 的语法 1lambda argument_list:expersion","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"算法-图论","slug":"算法笔记","date":"2022-05-06T05:46:49.000Z","updated":"2022-06-29T08:50:18.226Z","comments":true,"path":"2022/05/06/算法笔记/","link":"","permalink":"http://example.com/2022/05/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"图论知识 存图方式 作为一个图，如果要将它储存起来，自然是需要一种存图的方法。 这里使用的是链式前向星存图 最短路 最短路就是到某个点的最短路径的距离，最常用的有三种方法 bellman-ford 时间复杂度：O(n m) 可解决存在负边的情况 三角不等式：dis[b] &lt;= dis[a] + w 123456789101112131415161718192021222324252627282930313233343536373839/* 走k次能从1号点到n号点的最短路 */long long dis[N], last[N];struct E &#123; int u, v, w;&#125;Edge[M];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++ ) cin &gt;&gt; Edge[i].u &gt;&gt; Edge[i].v &gt;&gt; Edge[i].w; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; for (int i = 0; i &lt; k; i++ ) &#123; memcpy(last, dis, sizeof(dis)); for (int j = 0; j &lt; m; j++ ) &#123; auto e = Edge[j]; dis[e.v] = min(dis[e.v], last[e.u] + e.w); &#125; &#125; if (dis[n] &gt; 0x3f3f3f3f / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; Dijkstra 时间复杂度：O(mlogn) 没有负权边的稠密图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 求1到其他点的最短路 dis[i] 为到i点的最短距离 */#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10, M = 2e5 + 10;typedef pair &lt;long long, int&gt; PII;priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq; // 小根堆存放最小值 long long dis[N];bool vis[N];struct E &#123; int to, w, next;&#125;Edge[M];int tot, Head[N];inline void Add_edge(int u, int v, int w)&#123; Edge[tot] = &#123;v, w, Head[u]&#125;; Head[u] = tot ++;&#125;void dijkstra(int s)&#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; // 初始化距离1到它本身距离为0 pq.push(&#123;0, s&#125;); while(!pq.empty()) &#123; int u = pq.top().second; //对u进行操作 pq.pop(); // 操作完后弹出队列 if (vis[u]) continue; vis[u] = true; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (dis[u] + Edge[i].w &lt; dis[v]) // 松弛操作 &#123; dis[v] = dis[u] + Edge[i].w; // 更新最短路 pq.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; Add_edge(u, v, w); &#125; dijkstra(1); for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; dis[i] &lt;&lt; &#x27; &#x27;; return 0;&#125; SPFA 一般情况下时间复杂度为：O(m) 最坏：(nm) 可以判断负环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 1e5 + 10;int dis[N];bool st[N];struct E&#123; int to, next, w;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void addedge(int u, int v, int w)&#123; Edge[tot] = &#123;v, Head[u], w&#125;; Head[u] = tot ++;&#125;void spfa()&#123; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; queue &lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) &#123; int u = q.front(); q.pop(); st[u] = false; for (int i = Head[u]; ~i; i = Edge[i].next ) &#123; int v = Edge[i].to; if (dis[v] &gt; dis[u] + Edge[i].w) &#123; dis[v] = dis[u] + Edge[i].w; if (!st[v]) // 不存在就入队列 &#123; q.push(v); st[v] = true; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); int n, m; cin &gt;&gt; n &gt;&gt; m; while(m --) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; spfa(); if (dis[n] == 0x3f3f3f3f) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; Floyd(求多源汇) 多源汇就是任意两个点的最短路 时间复杂度：O(n ^ 3) 基于动态规划 更新：到只经过1到k-1个点跟到k个点的最小 12345678/* 实现后d[i][j] 就是i到j的最短路 */void floyd()&#123; for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; 最近公共祖先（lCA） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 给定一棵 n 个结点树和 m 次询问 (u,v)，请你回答 u,v 两个结点的最近公共祖先是谁 */#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 5e5 + 10;int n, m, s;struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];int dp[20][N], dep[N];inline void add_edge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot++;&#125;void dfs(int u, int f)&#123; dep[u] = dep[f] + 1; dp[0][u] = f; for (int i = 1; (1 &lt;&lt; i) &lt; dep[u]; i++ ) dp[i][u] = dp[i - 1][dp[i - 1][u]]; // 初始化dp数组 for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); &#125;&#125;int lca(int u, int v)&#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] != dep[v]) &#123; u = dp[(int)log2(dep[u] - dep[v])][u]; &#125; for (int i = 19; i &gt;= 0; i --) &#123; if (dp[i][u] != dp[i][v]) &#123; u = dp[i][u]; v = dp[i][v]; &#125; &#125; if (u == v) return u; else return dp[0][u];&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt; n; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; add_edge(u, v); add_edge(v, u); &#125; dfs(s, 0); while (m --) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; endl; &#125; return 0;&#125; 最长不下降子序列(LIS) 3 1 2 2 1 3 的最长不下降子序列为 1 2 2 3 123456for (int i = 1; i &lt;= n; i++ ) &#123; if (a[i] &gt;= d[len]) d[++len] = a[i]; else *upper_bound(d + 1, d + 1 + len, a[i]) = a[i]; &#125; cout &lt;&lt; len &lt;&lt; endl; 最长公共子序列(LCS) 标准版 给定两个数列，求他们的最长公共子序列 1234567for (int i = 1; i &lt;= n; i++ ) for (int j = 1; j &lt;= m; j++ ) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; 全排列版 给出 1,2,…,n 的两个排列 P1 和 P2，求它们的最长公共子序列 1234567891011for (int i = 1; i &lt;= n; i++ )1 mp[a[i]] = i;for (int i = 1; i &lt;= n; i++ ) b[i] = mp[b[i]]; //一个映射关系for (int i = 1; i &lt;= n; i++ )&#123; if (b[i] &gt;= d[len]) d[++len] = b[i]; else *upper_bound(d + 1, d + 1 + len, b[i]) = b[i];&#125;cout &lt;&lt; len &lt;&lt; endl; 树的重心 重心的性质： 对于非负权的数，树上所有点到树的重心的距离之和最短 一棵树的重心一定在根节点所在重链上 若向一棵树中插入或者删除一个点，那么树的重心最多移动一个单位 如果树有两个重心，那么这两个重心一定相邻 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 给定一棵树，求任意节点到一个固定节点的最小值 */#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;long long n, rt, siz[N], maxp[N], dep[N];long long ans;struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void add_edge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot ++;&#125;void dfs1(int u, int f)&#123; siz[u] = 1; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); siz[u] += siz[v]; maxp[u] = max(maxp[u], siz[v]); &#125; maxp[u] = max(maxp[u], n - siz[u]); if (maxp[u] &lt; maxp[rt]) rt = u; &#125;void dfs2(int u, int f)&#123; dep[u] = dep[f] + 1; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs1(v, u); &#125;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i ++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; add_edge(u, v); add_edge(v, u); &#125; maxp[rt] = n; dfs1(1, 0); dfs2(rt, 0); for (int i = 1; i &lt;= n; i ++ ) &#123; ans += dep[i] - dep[rt]; // 从重心到其他节点的距离 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 树的直径 树上节点之间最长的一条简单路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int ans, dep[N];struct E&#123; int to, next;&#125;Edge[N &lt;&lt; 1];int tot, Head[N];inline void addedge(int u, int v)&#123; Edge[tot] = &#123;v, Head[u]&#125;; Head[u] = tot ++; &#125;void dfs(int u, int f)&#123; for (int i = Head[u]; ~i; i = Edge[i].next) &#123; int v = Edge[i].to; if (v == f) continue; dfs(v, u); ans = max(ans, dep[v] + 1 + dep[u]); dep[u] = max(dep[u], dep[v] + 1); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); memset(Head, -1, sizeof(Head)); int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); addedge(v, u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最小生成树 Kruskal 匈牙利算法（二分图匹配） 给定一个二分图，其左部点的个数为 n，右部点的个数为 m，边数为 e，求其最大匹配的边数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int N = 510;vector &lt;int&gt; G[N];int match[N], vis[N];bool dfs(int u, int tag)&#123; if(vis[u] == tag) return false; vis[u] = tag; for(auto v : G[u]) &#123; if(!match[v] || dfs(match[v], tag)) &#123; match[v] = u; return true; &#125; &#125; return false;&#125;int main()&#123; int n, m, e, ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; e; for (int i = 0; i &lt; e; i++ ) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); &#125; for (int i = 1; i &lt;= n; i++ ) &#123; if (dfs(i, i)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"test","slug":"test","date":"2022-04-27T09:23:25.000Z","updated":"2022-09-03T10:31:06.949Z","comments":true,"path":"2022/04/27/test/","link":"","permalink":"http://example.com/2022/04/27/test/","excerpt":"","text":"2023年还没到… 小心开车 安全至上 这是三片呢？还是四片？ 你电量充足吗 剪刀石头布 前端最讨厌的浏览器 tag-hide 門裏站着一個人? Click 不 是两个","categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"主题","slug":"主题","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"},{"name":"学习记录","slug":"学习记录","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"},{"name":"感悟","slug":"感悟","permalink":"http://example.com/tags/%E6%84%9F%E6%82%9F/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"主题","slug":"主题","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}